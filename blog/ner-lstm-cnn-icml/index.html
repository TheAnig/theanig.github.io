<!doctype html><html data-theme=light lang=en xmlns=http://www.w3.org/1999/xhtml><head><meta charset=UTF-8><meta content="This is my own personal corner of the internet" name=description><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#00bf63 name=theme-color><title>End-to-end Sequence-Labeling via Bi-directional LSTM CNNs CRF Tutorial - TheAnig</title><link href=https://theanig.github.io/blog/ner-lstm-cnn-icml/ rel=canonical><link href=https://theanig.github.io/favicon.png rel=icon type=image/png><link href=https://theanig.github.io/apple-touch-icon.png rel=apple-touch-icon sizes=180x180 type=image/png><link title="TheAnig - RSS Feed" href=https://theanig.github.io/rss.xml rel=alternate type=application/rss+xml><link title="TheAnig - Atom Feed" href=https://theanig.github.io/atom.xml rel=alternate type=application/atom+xml><style>:root{--accent-color:#00bf63}</style><link href=https://theanig.github.io/style.css rel=stylesheet><link href=https://theanig.github.io/katex.css rel=stylesheet><script defer src=https://theanig.github.io/closable.js></script><script defer src=https://theanig.github.io/copy-button.js></script><script data-goatcounter=https://stats.theanig.dev/count defer src=https://theanig.github.io/count.js></script><script defer src=https://theanig.github.io/katex.min.js></script><script defer src=https://theanig.github.io/auto-render.min.js></script><script defer src=https://theanig.github.io/katex-init.js></script><script defer src=https://theanig.github.io/elasticlunr.min.js></script><script defer src=https://theanig.github.io/search-elasticlunr.js></script><meta content=TheAnig property=og:site_name><meta content="End-to-end Sequence-Labeling via Bi-directional LSTM CNNs CRF Tutorial - TheAnig" property=og:title><meta content=https://theanig.github.io/blog/ner-lstm-cnn-icml/ property=og:url><meta content="This is a PyTorch tutorial for the ACL'16 paper End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF, presented at ICML 2018" property=og:description><meta content=https://theanig.github.io/card.png property=og:image><meta content=en_US property=og:locale><body><div id=handle></div><header id=site-nav><nav><a href=#main-content tabindex=0> Skip to Main Content </a><ul><li id=home><a href=https://theanig.github.io> <i class=icon></i>TheAnig</a><li class=divider><li><a href=https://theanig.github.io/blog/>Blog</a><li id=search><button class=circle id=search-toggle title=Search><i class=icon></i></button><li id=theme-switcher><details class=closable><summary class=circle title=Theme><i class=icon></i></summary> <ul><li><button title="Switch to Light Theme" class=circle id=theme-light><i class=icon></i></button><li><button title="Switch to Dark Theme" class=circle id=theme-dark><i class=icon></i></button><li><button title="Use System Theme" class=circle id=theme-system><i class=icon></i></button></ul></details><li id=feed><details class=closable><summary class=circle title=Feed><i class=icon></i></summary> <ul><li><a href=https://theanig.github.io/rss.xml>RSS</a><li><a href=https://theanig.github.io/atom.xml>Atom</a></ul></details></ul></nav><div id=search-container><label class=visually-hidden for=search-bar>Search</label><input placeholder="Search for…" autocomplete=off disabled id=search-bar type=search><div id=search-results-container><div id=search-results></div></div></div></header><main id=main-content><article><div id=heading><p><small> <time datetime=" 2018-08-25T00:00:00+00:00">Published on August 25, 2018</time></small><h1>End-to-end Sequence-Labeling via Bi-directional LSTM CNNs CRF Tutorial</h1><ul class=tags><li><a class=tag href=https://theanig.github.io/tags/ner-icml-project/>ner-icml-project</a><li><a class=tag href=https://theanig.github.io/tags/deep-learning/>deep-learning</a><li><a class=tag href=https://theanig.github.io/tags/text-classification/>text-classification</a></ul></div><div id=buttons-container><details class=closable id=toc><summary title="Table of Contents"><i class=icon></i></summary> <div><strong class=title>Table of Contents</strong><div><ul><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#introduction>Introduction</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#reproducibility>Reproducibility</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#tutorial>Tutorial</a><ul><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#data-preparation>Data Preparation</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#mappings-and-word-embeddings>Mappings and Word Embeddings</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#model-architecture>Model Architecture</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#model-details>Model Details</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#training-the-model>Training the model</a><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#evaluation-and-testing>Evaluation and Testing</a></ul><li><a href=https://theanig.github.io/blog/ner-lstm-cnn-icml/#closing-thoughts>Closing Thoughts</a></ul></div></div></details><a title="Go to Top" href=#top id=go-to-top><i class=icon></i></a><a href="https://shareopenly.org/share/?url=https://theanig.github.io/blog/ner-lstm-cnn-icml/&text=This%20is%20a%20PyTorch%20tutorial%20for%20the%20ACL%2716%20paper%20End-to-end%20Sequence%20Labeling%20via%20Bi-directional%20LSTM-CNNs-CRF%2C%20presented%20at%20ICML%202018" id=share title=Share><i class=icon></i></a><a title="File an Issue" href=https://github.com/TheAnig/theanig.github.io/issues id=issue><i class=icon></i></a></div><h2 id=introduction>Introduction</h2><p>If you’ve ever dipped your toes into natural language processing (NLP), you’ve probably come across tasks like part-of-speech (POS) tagging and named entity recognition (NER). These are the bread and butter of understanding text—things like figuring out whether “Apple” in a sentence refers to a fruit or a tech giant. But let’s be honest, the traditional ways of handling these tasks? Not exactly user-friendly. They usually involve manually crafting features and preprocessing data for hours. It’s tedious, time-consuming, and doesn’t always translate well when you try to apply it to new types of text.<p>That’s where a groundbreaking paper from ACL 2016 comes in: End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF by Xuezhe Ma and Eduard Hovy<sup class=footnote-reference id=fr-1-1><a href=#fn-1>[1]</a></sup>. Don’t let the fancy title scare you—this paper is a game-changer. It proposes a neural network model that completely flips the script on the traditional approach. Instead of hand-picking features, it combines character-level representations (thanks to Convolutional Neural Networks, or CNNs) with word-level context (handled by Bi-directional LSTMs). The cherry on top? A Conditional Random Field (CRF) layer that ties everything together for structured predictions.<p>What’s so cool about this? Well, for starters, it’s an end-to-end model, which means it handles the entire process without requiring you to do all that annoying feature engineering. You just give it data, and it learns what it needs—automatically. It’s versatile too, working across a range of sequence labeling tasks.<p>And the results? Pretty impressive. This model hit 97.55% accuracy on POS tagging with the Penn Treebank WSJ dataset and scored a solid 91.21% F1 on NER using the CoNLL 2003 dataset. Those are state-of-the-art numbers, by the way.<p>Since its debut, this paper has left a big mark on the NLP community. It’s inspired a wave of follow-up research and implementations, all riffing on this idea of combining different neural network components into a single powerful system. This emphasis on end-to-end learning has made sequence labeling faster, easier, and way more adaptable.<h2 id=reproducibility>Reproducibility</h2><p>This is why I took this paper as a good candidate to present for reproducibility<sup class=footnote-reference id=fr-2-1><a href=#fn-2>[2]</a></sup>.<p>It’s a standout example of a complex yet impactful model, combining multiple neural network components into an end-to-end framework. The paper doesn’t just offer strong theoretical contributions; it also provides practical results that have influenced a significant portion of subsequent NLP research. By breaking down the BiLSTM-CNN-CRF model step-by-step, I wanted to demonstrate how a state-of-the-art system could be reproduced with modern tools like PyTorch, ensuring others could verify the results and, ideally, build upon them.<p>Reproducibility in this case meant more than just rerunning the experiments—it meant making the implementation accessible, understandable, and adaptable to different use cases. During my preparation, I paid close attention to the potential pain points: ensuring the code was platform-agnostic, tuning hyperparameters to match those used in the paper, and structuring the codebase so others could easily tweak it for related tasks. The aim was to not only replicate the model’s impressive benchmark performance but to encourage further experimentation and adoption by the community.<p>At the ICML workshop, this example opened up broader conversations about what it takes to make machine learning research truly reproducible. The discussion often circled back to the tools we use to share code and results. For instance, while frameworks like PyTorch offer flexibility and power, simply uploading a GitHub repository isn’t enough if it lacks proper documentation or doesn’t account for different computational setups. The group also explored the importance of including detailed training procedures and hyperparameter configurations—often overlooked but critical for achieving comparable results.<h2 id=tutorial>Tutorial</h2><blockquote class=note><p class=alert-title><i class=icon></i>Note<p>Feel free to check out the linked repository to follow along with this article to implement your own state of the art NER pipeline</blockquote><h3 id=data-preparation>Data Preparation</h3><p>Before we dive into the model, let’s prepare the data. We’ll use the CoNLL 2003 dataset, which contains text tagged for four types of named entities: PERSON, LOCATION, ORGANIZATION, and MISC.<p>The dataset uses the BIO tagging scheme, where:<ul><li>B-TYPE indicates the beginning of an entity of type TYPE.<li>I-TYPE indicates the continuation of the entity.<li>O indicates that the word is not part of any entity.</ul><p>For example,<pre class=language-mathematica data-lang=mathematica style=color:#c0c5ce;background-color:#2b303b><code class=language-mathematica data-lang=mathematica><span>U.N.         NNP  I-NP  I-ORG
</span><span>official     NN   I-NP  O
</span><span>Ekeus        NNP  I-NP  I-PER
</span><span>heads        VBZ  I-VP  O
</span><span>for          IN   I-PP  O
</span><span>Baghdad      NNP  I-NP  I-LOC
</span></code></pre><p>We also preprocess the text by replacing all digits with 0. This step ensures that the model focuses on meaningful textual patterns instead of numeric details, which are often irrelevant in NER tasks.<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>zero_digits</span><span>(</span><span style=color:#bf616a>s</span><span>):
</span><span>    </span><span style=color:#b48ead>return </span><span>re.</span><span style=color:#bf616a>sub</span><span>('</span><span style=color:#96b5b4>\\</span><span style=color:#a3be8c>d</span><span>', '</span><span style=color:#a3be8c>0</span><span>', s)
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>load_sentences</span><span>(</span><span style=color:#bf616a>path</span><span>, </span><span style=color:#bf616a>zeros</span><span>):
</span><span>    sentences = []
</span><span>    sentence = []
</span><span>    </span><span style=color:#b48ead>for </span><span>line </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>open</span><span>(path, '</span><span style=color:#a3be8c>r</span><span>', </span><span style=color:#bf616a>encoding</span><span>='</span><span style=color:#a3be8c>utf-8</span><span>'):
</span><span>        line = </span><span style=color:#bf616a>zero_digits</span><span>(line.</span><span style=color:#bf616a>rstrip</span><span>()) </span><span style=color:#b48ead>if </span><span>zeros </span><span style=color:#b48ead>else </span><span>line.</span><span style=color:#bf616a>rstrip</span><span>()
</span><span>        </span><span style=color:#b48ead>if </span><span>not line:
</span><span>            </span><span style=color:#b48ead>if </span><span style=color:#96b5b4>len</span><span>(sentence) > </span><span style=color:#d08770>0</span><span>:
</span><span>                sentences.</span><span style=color:#bf616a>append</span><span>(sentence)
</span><span>                sentence = []
</span><span>        </span><span style=color:#b48ead>else</span><span>:
</span><span>            word = line.</span><span style=color:#bf616a>split</span><span>()
</span><span>            </span><span style=color:#b48ead>assert </span><span style=color:#96b5b4>len</span><span>(word) >= </span><span style=color:#d08770>2
</span><span>            sentence.</span><span style=color:#bf616a>append</span><span>(word)
</span><span>    </span><span style=color:#b48ead>return </span><span>sentences
</span></code></pre><p>To align with the paper, we convert the tags to the BIOES scheme, which provides finer granularity by adding:<ul><li>E-TYPE for the end of an entity.<li>S-TYPE for single-token entities.</ul><pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>iob_iobes</span><span>(</span><span style=color:#bf616a>tags</span><span>):
</span><span>    </span><span style=color:#65737e>"""
</span><span style=color:#65737e>    the function is used to convert
</span><span style=color:#65737e>    BIO -> BIOES tagging
</span><span style=color:#65737e>    """
</span><span>    new_tags = []
</span><span>    </span><span style=color:#b48ead>for </span><span>i, tag </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>enumerate</span><span>(tags):
</span><span>        </span><span style=color:#b48ead>if </span><span>tag == '</span><span style=color:#a3be8c>O</span><span>':
</span><span>            new_tags.</span><span style=color:#bf616a>append</span><span>(tag)
</span><span>        </span><span style=color:#b48ead>elif </span><span>tag.</span><span style=color:#bf616a>split</span><span>('</span><span style=color:#a3be8c>-</span><span>')[</span><span style=color:#d08770>0</span><span>] == '</span><span style=color:#a3be8c>B</span><span>':
</span><span>            </span><span style=color:#b48ead>if </span><span>i + </span><span style=color:#d08770>1 </span><span>!= </span><span style=color:#96b5b4>len</span><span>(tags) and \
</span><span>               tags[i + </span><span style=color:#d08770>1</span><span>].</span><span style=color:#bf616a>split</span><span>('</span><span style=color:#a3be8c>-</span><span>')[</span><span style=color:#d08770>0</span><span>] == '</span><span style=color:#a3be8c>I</span><span>':
</span><span>                new_tags.</span><span style=color:#bf616a>append</span><span>(tag)
</span><span>            </span><span style=color:#b48ead>else</span><span>:
</span><span>                new_tags.</span><span style=color:#bf616a>append</span><span>(tag.</span><span style=color:#bf616a>replace</span><span>('</span><span style=color:#a3be8c>B-</span><span>', '</span><span style=color:#a3be8c>S-</span><span>'))
</span><span>        </span><span style=color:#b48ead>elif </span><span>tag.</span><span style=color:#bf616a>split</span><span>('</span><span style=color:#a3be8c>-</span><span>')[</span><span style=color:#d08770>0</span><span>] == '</span><span style=color:#a3be8c>I</span><span>':
</span><span>            </span><span style=color:#b48ead>if </span><span>i + </span><span style=color:#d08770>1 </span><span>< </span><span style=color:#96b5b4>len</span><span>(tags) and \
</span><span>                    tags[i + </span><span style=color:#d08770>1</span><span>].</span><span style=color:#bf616a>split</span><span>('</span><span style=color:#a3be8c>-</span><span>')[</span><span style=color:#d08770>0</span><span>] == '</span><span style=color:#a3be8c>I</span><span>':
</span><span>                new_tags.</span><span style=color:#bf616a>append</span><span>(tag)
</span><span>            </span><span style=color:#b48ead>else</span><span>:
</span><span>                new_tags.</span><span style=color:#bf616a>append</span><span>(tag.</span><span style=color:#bf616a>replace</span><span>('</span><span style=color:#a3be8c>I-</span><span>', '</span><span style=color:#a3be8c>E-</span><span>'))
</span><span>        </span><span style=color:#b48ead>else</span><span>:
</span><span>            </span><span style=color:#b48ead>raise </span><span style=color:#bf616a>Exception</span><span>('</span><span style=color:#a3be8c>Invalid IOB format!</span><span>')
</span><span>    </span><span style=color:#b48ead>return </span><span>new_tags
</span></code></pre><h3 id=mappings-and-word-embeddings>Mappings and Word Embeddings</h3><p>To train our model, we need to convert words, characters, and tags into numeric representations. This mapping allows us to leverage efficient matrix operations in PyTorch. For word embeddings, we use pre-trained GloVe vectors (100-dimensional) trained on Wikipedia and Gigaword data. These embeddings provide a semantic representation of words, which significantly boosts the model’s performance.<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>word_to_id, id_to_word = </span><span style=color:#bf616a>create_mapping</span><span>(train_sentences)
</span><span>char_to_id, id_to_char = </span><span style=color:#bf616a>create_mapping</span><span>(train_sentences, </span><span style=color:#bf616a>level</span><span>='</span><span style=color:#a3be8c>char</span><span>')
</span><span>tag_to_id, id_to_tag = </span><span style=color:#bf616a>create_mapping</span><span>(train_sentences, </span><span style=color:#bf616a>level</span><span>='</span><span style=color:#a3be8c>tag</span><span>')
</span></code></pre><p>We also load GloVe embeddings into a matrix and initialize missing embeddings randomly:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>word_embeds = np.random.</span><span style=color:#bf616a>uniform</span><span>(-np.</span><span style=color:#bf616a>sqrt</span><span>(</span><span style=color:#d08770>0.06</span><span>), np.</span><span style=color:#bf616a>sqrt</span><span>(</span><span style=color:#d08770>0.06</span><span>), (</span><span style=color:#96b5b4>len</span><span>(word_to_id), </span><span style=color:#d08770>100</span><span>))
</span><span style=color:#b48ead>for </span><span>word </span><span style=color:#b48ead>in </span><span>word_to_id:
</span><span>    </span><span style=color:#b48ead>if </span><span>word in glove_embeds:
</span><span>        word_embeds[word_to_id[word]] = glove_embeds[word]
</span></code></pre><h3 id=model-architecture>Model Architecture</h3><p>The BiLSTM-CNN-CRF model has three main components:<ul><li><p>CNN for Character Embeddings: Generates a character-level representation for each word using convolutional and max-pooling layers. This step captures morphological patterns like prefixes and suffixes.</p><li><p>BiLSTM for Word Encoding: Combines word embeddings (GloVe + character embeddings) and processes them bidirectionally. This helps capture context from both the left and right of each word.</p><li><p>CRF for Structured Prediction: Ensures that predictions respect tagging constraints (e.g., I-ORG cannot follow I-PER).</p></ul><p>The model that we are presenting is a complicated one, since its a hybridized network using LSTMs and CNNs. So in order to break down the complexity, we have attempted to simplify the process by splitting up operations into individual functions that we can go over part by part. This hopefully makes the whole thing more easily digestable and gives a more intuitive understanding of the whole process.<h4 id=initialization-of-weights>Initialization of weights</h4><p>We start with the init_embedding function, which just initializes the embedding layer by pooling from a random sample.<p>The distribution is pooled from $-\sqrt{\frac{3}{V}}$ to $+\sqrt{\frac{3}{V}}$ where $V$ is the embedding dimension size.<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>    bias = np.</span><span style=color:#bf616a>sqrt</span><span>(</span><span style=color:#d08770>3.0 </span><span>/ input_embedding.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>1</span><span>))
</span><span>    nn.init.</span><span style=color:#bf616a>uniform</span><span>(input_embedding, -bias, bias)
</span></code></pre><p>The LSTM layers are initialized by uniform sampling from $-\sqrt{\frac{6}{r + c}}$ to $+\sqrt{\frac{6}{r + c}}$. Where $r$ is the number of rows, $c$ is the number of columns (based on the shape of the weight matrix).<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>    bias = np.</span><span style=color:#bf616a>sqrt</span><span>(</span><span style=color:#d08770>6.0 </span><span>/ (input_linear.weight.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>0</span><span>) + input_linear.weight.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>1</span><span>)))
</span><span>    nn.init.</span><span style=color:#bf616a>uniform</span><span>(input_linear.weight, -bias, bias)
</span></code></pre><h4 id=crf-layer>CRF Layer</h4><p>We have two options:<ul><li><p><strong>softmax</strong>: normalize the scores into a vector such that can be interpreted as the probability that the word belongs to class. Eventually, the probability of a sequence of tag $y$ is the product of all tags.</p><li><p><strong>linear-chain CRF</strong>: the first method makes local choices. In other words, even if we capture some information from the context thanks to the bi-LSTM, the tagging decision is still local. We don’t make use of the neighbooring tagging decisions. Given a sequence of words $w_1, …, w_m$, a sequence of score vectors $s_1, …, s_m$ and a sequence of tags $y_1, …, y_m$, a linear-chain CRF defines a global score $C \in \R$ such that</p></ul><p>$$ C(y_1, …, y_m) = b[y_1] + \sum_{t=1}^m s_t[y_t] + \sum_{t=1}^{m-1}T[y_t, y_{t+1}] + e[y_m] $$<p>where $T$ is a transition matrix in $\R^{9x9}$ and $e, b \in \R^9$ are vectors of scores that capture the cost of beginning or ending with a given tag. The use of the matrix $T$ captures linear (one step) dependencies between tagging decisions.<p>The motivation behind CRFs was to generate sentence level likelihoods for optimal tags. What that means is for each word we estimate maximum likelihood and then we use the Viterbi algorithm to decode the tag sequence optimally.<p><strong>Advantages of CRF over Softmax:</strong><ul><li>Softmax doesn’t value any dependencies, this is a problem since NER the context heavily influences the tag that is assigned. This is solved by applying CRF as it takes into account the full sequence to assign the tag.<li>Example: I-ORG cannot directly follow I-PER.</ul><figure><img alt="A simple CRF network" src=simple_crf_network.svg><figcaption>A simple CRF network</figcaption></figure><p>The figure shows a simple CRF network, in our case we have the inputs feeding in from our BiLSTMs, but otherwise the structure largely remains the same.<h4 id=score-calculation>Score Calculation</h4><p>CRF computes a conditional probability. Let $y$ be a tag sequence and x an input of sequence of words. Then we compute $$ P(y|x) = \frac{exp(Score(x, y))}{\sum_{y’}exp(Score(x, y’))} $$<p>Where the score is determined by defining some log potentials $log\psi_i(x, y)$ such that $$ Score(x, y) = \sum_i log\psi_i(x, y) $$<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>log_sum_exp</span><span>(</span><span style=color:#bf616a>vec</span><span>):
</span><span>    </span><span style=color:#65737e>'''
</span><span style=color:#65737e>    This function calculates the score explained above for the forward algorithm
</span><span style=color:#65737e>    vec 2D: 1 * tagset_size
</span><span style=color:#65737e>    '''
</span><span>    max_score = vec[</span><span style=color:#d08770>0</span><span>, </span><span style=color:#bf616a>argmax</span><span>(vec)]
</span><span>    max_score_broadcast = max_score.</span><span style=color:#bf616a>view</span><span>(</span><span style=color:#d08770>1</span><span>, -</span><span style=color:#d08770>1</span><span>).</span><span style=color:#bf616a>expand</span><span>(</span><span style=color:#d08770>1</span><span>, vec.</span><span style=color:#bf616a>size</span><span>()[</span><span style=color:#d08770>1</span><span>])
</span><span>    </span><span style=color:#b48ead>return </span><span>max_score + torch.</span><span style=color:#bf616a>log</span><span>(torch.</span><span style=color:#bf616a>sum</span><span>(torch.</span><span style=color:#bf616a>exp</span><span>(vec - max_score_broadcast)))
</span></code></pre><p>This is the score function for our sentences. This function takes a list of ground truths that tell us what the corresponding tags are and the features which contains the supposed tagged parts of the function. Which is then used to compute the score.<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>score_sentences</span><span>(</span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>feats</span><span>, </span><span style=color:#bf616a>tags</span><span>):
</span><span>    </span><span style=color:#65737e># tags is ground_truth, a list of ints, length is len(sentence)
</span><span>    </span><span style=color:#65737e># feats is a 2D tensor, len(sentence) * tagset_size
</span><span>    r = torch.</span><span style=color:#bf616a>LongTensor</span><span>(</span><span style=color:#96b5b4>range</span><span>(feats.</span><span style=color:#bf616a>size</span><span>()[</span><span style=color:#d08770>0</span><span>]))
</span><span>    </span><span style=color:#b48ead>if </span><span style=color:#bf616a>self</span><span>.use_gpu:
</span><span>        r = r.</span><span style=color:#bf616a>cuda</span><span>()
</span><span>        pad_start_tags = torch.</span><span style=color:#bf616a>cat</span><span>([torch.cuda.</span><span style=color:#bf616a>LongTensor</span><span>([</span><span style=color:#bf616a>self</span><span>.tag_to_ix[</span><span style=color:#bf616a>START_TAG</span><span>]]), tags])
</span><span>        pad_stop_tags = torch.</span><span style=color:#bf616a>cat</span><span>([tags, torch.cuda.</span><span style=color:#bf616a>LongTensor</span><span>([</span><span style=color:#bf616a>self</span><span>.tag_to_ix[</span><span style=color:#bf616a>STOP_TAG</span><span>]])])
</span><span>    </span><span style=color:#b48ead>else</span><span>:
</span><span>        pad_start_tags = torch.</span><span style=color:#bf616a>cat</span><span>([torch.</span><span style=color:#bf616a>LongTensor</span><span>([</span><span style=color:#bf616a>self</span><span>.tag_to_ix[</span><span style=color:#bf616a>START_TAG</span><span>]]), tags])
</span><span>        pad_stop_tags = torch.</span><span style=color:#bf616a>cat</span><span>([tags, torch.</span><span style=color:#bf616a>LongTensor</span><span>([</span><span style=color:#bf616a>self</span><span>.tag_to_ix[</span><span style=color:#bf616a>STOP_TAG</span><span>]])])
</span><span>
</span><span>    score = torch.</span><span style=color:#bf616a>sum</span><span>(</span><span style=color:#bf616a>self</span><span>.transitions[pad_stop_tags, pad_start_tags]) + torch.</span><span style=color:#bf616a>sum</span><span>(feats[r, tags])
</span><span>
</span><span>    </span><span style=color:#b48ead>return </span><span>score
</span></code></pre><h4 id=viterbi-decode>Viterbi decode</h4><p>Viterbi decode is basically applying dynamic programming to choosing our tag sequence. Let’s suppose that we have the solution<p>$$ \tilde s_t(y_t) = argmax_{y_t, …, y_m} C(y_t, …, y_m) = argmax_{y_{t+1}}s_t[y_t] + T[y_t, y_{t+1}] + \tilde s_{t+1}(y^{t+1}) $$<p>Then, we can easily define the probability of a given sequence of tags as<p>$$ \mathbb{P}(y_1, …, y_m) = \frac{e^{C(y_t, …, y_m)}}{Z} $$<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>forward_calc</span><span>(</span><span style=color:#bf616a>self</span><span>, </span><span style=color:#bf616a>sentence</span><span>, </span><span style=color:#bf616a>chars</span><span>, </span><span style=color:#bf616a>chars2_length</span><span>, </span><span style=color:#bf616a>d</span><span>):
</span><span>
</span><span>    </span><span style=color:#65737e>'''
</span><span style=color:#65737e>    The function calls viterbi decode and generates the
</span><span style=color:#65737e>    most probable sequence of tags for the sentence
</span><span style=color:#65737e>    '''
</span><span>
</span><span>    </span><span style=color:#65737e># Get the emission scores from the BiLSTM
</span><span>    feats = </span><span style=color:#bf616a>self</span><span>.</span><span style=color:#bf616a>_get_lstm_features</span><span>(sentence, chars, chars2_length, d)
</span><span>    </span><span style=color:#65737e># viterbi to get tag_seq
</span><span>
</span><span>    </span><span style=color:#65737e># Find the best path, given the features.
</span><span>    </span><span style=color:#b48ead>if </span><span style=color:#bf616a>self</span><span>.use_crf:
</span><span>        score, tag_seq = </span><span style=color:#bf616a>self</span><span>.</span><span style=color:#bf616a>viterbi_decode</span><span>(feats)
</span><span>    </span><span style=color:#b48ead>else</span><span>:
</span><span>        score, tag_seq = torch.</span><span style=color:#bf616a>max</span><span>(feats, </span><span style=color:#d08770>1</span><span>)
</span><span>        tag_seq = </span><span style=color:#bf616a>list</span><span>(tag_seq.</span><span style=color:#bf616a>cpu</span><span>().data)
</span><span>
</span><span>    </span><span style=color:#b48ead>return </span><span>score, tag_seq
</span></code></pre><h3 id=model-details>Model Details</h3><h4 id=cnn-model-for-generating-character-embeddings>CNN model for generating character embeddings</h4><p>Consider the word ‘cat’, we pad it on both ends to get our maximum word length ( this is mainly an implementation quirk since we can’t have variable length layers at run time, our algorithm will ignore the pads).<figure><img alt="Convolution Model for generating character embeddings" src=convolution_model_details.svg><figcaption>Convolution Model for generating character embeddings</figcaption></figure> We then apply a convolution layer on top that generates spatial coherence across characters, we use a maxpool to extract meaningful features out of our convolution layer. This now gives us a dense vector representation of each word. This representation will be concatenated with the pre-trained GloVe embeddings using a simple lookup. <p>This snippet shows us how the CNN is implemented in pytorch<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#bf616a>self</span><span>.char_cnn3 = nn.</span><span style=color:#bf616a>Conv2d</span><span>(</span><span style=color:#bf616a>in_channels</span><span>=</span><span style=color:#d08770>1</span><span>, </span><span style=color:#bf616a>out_channels</span><span>=</span><span style=color:#bf616a>self</span><span>.out_channels, </span><span style=color:#bf616a>kernel_size</span><span>=(</span><span style=color:#d08770>3</span><span>, char_embedding_dim), </span><span style=color:#bf616a>padding</span><span>=(</span><span style=color:#d08770>2</span><span>,</span><span style=color:#d08770>0</span><span>))
</span></code></pre><h4 id=lstm-model-that-generates-tags-for-the-given-sequence>LSTM model that generates tags for the given sequence</h4><p>The word-embeddings( glove+char embedding ) that we generated above, we feed to a bi-directional LSTM model. The LSTM model has 2 layers,<figure><img alt="LSTMs for Tag Generation" src=lstm_based_tag_generation.svg><figcaption>LSTMs for Tag Generation</figcaption></figure><ul><li><p>The forward layer takes in a sequence of word vectors and generates a new vector based on what it has seen so far in the forward direction (starting from the start word up until current word) this vector can be thought of as a summary of all the words it has seen.</p><li><p>The backwards layer does the same but in opposite direction, i.e., from the end of the sentence to the current word.</p><li><p>The forward vector and the backwards vector at current word concatanate to generate a unified representation.</p></ul><p>This snippet shows us how the BiLSTM is implemented in pytorch<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#bf616a>self</span><span>.lstm = nn.</span><span style=color:#bf616a>LSTM</span><span>(embedding_dim+</span><span style=color:#bf616a>self</span><span>.out_channels, hidden_dim, </span><span style=color:#bf616a>bidirectional</span><span>=</span><span style=color:#d08770>True</span><span>)
</span></code></pre><h4 id=main-model-implementation>Main Model Implementation</h4><p>The get_lstm_features function returns the LSTM’s tag vectors. The function performs all the steps mentioned above for the model.<p>Steps:<ul><li>It takes in characters, converts them to embeddings using our character CNN.<li>We concat Character Embeeding with glove vectors, use this as features that we feed to Bidirectional-LSTM.<li>The Bidirectional-LSTM generates outputs based on these set of features.<li>The output are passed through a linear layer to convert to tag space</ul><pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>if </span><span style=color:#bf616a>self</span><span>.char_mode == '</span><span style=color:#a3be8c>LSTM</span><span>':
</span><span>    chars_embeds = </span><span style=color:#bf616a>self</span><span>.</span><span style=color:#bf616a>char_embeds</span><span>(chars2).</span><span style=color:#bf616a>transpose</span><span>(</span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>1</span><span>)
</span><span>    packed = torch.nn.utils.rnn.</span><span style=color:#bf616a>pack_padded_sequence</span><span>(chars_embeds, chars2_length)
</span><span>    lstm_out, </span><span style=color:#bf616a>_ </span><span>= </span><span style=color:#bf616a>self</span><span>.</span><span style=color:#bf616a>char_lstm</span><span>(packed)
</span><span>    outputs, output_lengths = torch.nn.utils.rnn.</span><span style=color:#bf616a>pad_packed_sequence</span><span>(lstm_out)
</span><span>    outputs = outputs.</span><span style=color:#bf616a>transpose</span><span>(</span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>1</span><span>)
</span><span>    chars_embeds_temp = </span><span style=color:#bf616a>Variable</span><span>(torch.</span><span style=color:#bf616a>FloatTensor</span><span>(torch.</span><span style=color:#bf616a>zeros</span><span>((outputs.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>0</span><span>), outputs.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>2</span><span>)))))
</span><span>    </span><span style=color:#b48ead>if </span><span style=color:#bf616a>self</span><span>.use_gpu:
</span><span>        chars_embeds_temp = chars_embeds_temp.</span><span style=color:#bf616a>cuda</span><span>()
</span><span>    </span><span style=color:#b48ead>for </span><span>i, index </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>enumerate</span><span>(output_lengths):
</span><span>        chars_embeds_temp[i] = torch.</span><span style=color:#bf616a>cat</span><span>((outputs[i, index-</span><span style=color:#d08770>1</span><span>, :</span><span style=color:#bf616a>self</span><span>.char_lstm_dim], outputs[i, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#bf616a>self</span><span>.char_lstm_dim:]))
</span><span>    chars_embeds = chars_embeds_temp.</span><span style=color:#bf616a>clone</span><span>()
</span><span>    </span><span style=color:#b48ead>for </span><span>i </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>range</span><span>(chars_embeds.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>0</span><span>)):
</span><span>        chars_embeds[d[i]] = chars_embeds_temp[i]
</span><span>
</span><span style=color:#b48ead>if </span><span style=color:#bf616a>self</span><span>.char_mode == '</span><span style=color:#a3be8c>CNN</span><span>':
</span><span>    chars_embeds = </span><span style=color:#bf616a>self</span><span>.</span><span style=color:#bf616a>char_embeds</span><span>(chars2).</span><span style=color:#bf616a>unsqueeze</span><span>(</span><span style=color:#d08770>1</span><span>)
</span><span>    </span><span style=color:#65737e>## Creating Character level representation using Convolutional Neural Netowrk
</span><span>    </span><span style=color:#65737e>## followed by a Maxpooling Layer
</span><span>    chars_cnn_out3 = </span><span style=color:#bf616a>self</span><span>.</span><span style=color:#bf616a>char_cnn3</span><span>(chars_embeds)
</span><span>    chars_embeds = nn.functional.</span><span style=color:#bf616a>max_pool2d</span><span>(chars_cnn_out3,
</span><span>    </span><span style=color:#bf616a>kernel_size</span><span>=(chars_cnn_out3.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>2</span><span>), </span><span style=color:#d08770>1</span><span>)).</span><span style=color:#bf616a>view</span><span>(chars_cnn_out3.</span><span style=color:#bf616a>size</span><span>(</span><span style=color:#d08770>0</span><span>), </span><span style=color:#bf616a>self</span><span>.out_channels)
</span></code></pre><h3 id=training-the-model>Training the model</h3><p>We train the model using stochastic gradient descent (SGD) with a learning rate of 0.015 and momentum of 0.9. To avoid overfitting, we apply dropout and use gradient clipping<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>optimizer = torch.optim.</span><span style=color:#bf616a>SGD</span><span>(model.</span><span style=color:#bf616a>parameters</span><span>(), </span><span style=color:#bf616a>lr</span><span>=</span><span style=color:#d08770>0.015</span><span>, </span><span style=color:#bf616a>momentum</span><span>=</span><span style=color:#d08770>0.9</span><span>)
</span></code></pre><p>We also calculate the negative log-likelihood as our loss function:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>neg_log_likelihood</span><span>(</span><span style=color:#bf616a>sentence</span><span>, </span><span style=color:#bf616a>tags</span><span>):
</span><span>    feats = </span><span style=color:#bf616a>get_lstm_features</span><span>(sentence)
</span><span>    forward_score = </span><span style=color:#bf616a>forward_algorithm</span><span>(feats)
</span><span>    gold_score = </span><span style=color:#bf616a>score_sentence</span><span>(feats, tags)
</span><span>    </span><span style=color:#b48ead>return </span><span>forward_score - gold_score
</span></code></pre><h3 id=evaluation-and-testing>Evaluation and Testing</h3><p>After training, we evaluate the model using precision, recall, and F1-score. Here’s an example of the model tagging new sentences:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>sentence = "</span><span style=color:#a3be8c>Jay is from India.</span><span>"
</span><span>prediction = model.</span><span style=color:#bf616a>predict</span><span>(sentence)
</span><span style=color:#96b5b4>print</span><span>(prediction)
</span></code></pre><p>This gives us the output:<pre class=language-yaml data-lang=yaml style=color:#c0c5ce;background-color:#2b303b><code class=language-yaml data-lang=yaml><span style=color:#bf616a>Jay </span><span>: </span><span style=color:#a3be8c>PER
</span><span style=color:#bf616a>is </span><span>: </span><span style=color:#a3be8c>NA
</span><span style=color:#bf616a>from </span><span>: </span><span style=color:#a3be8c>NA
</span><span style=color:#bf616a>India </span><span>: </span><span style=color:#a3be8c>LOC
</span></code></pre><p>… and that’s it! That gets us a state of the art NER pipeline!<h2 id=closing-thoughts>Closing Thoughts</h2><p>Presenting this work at the workshop was an incredibly rewarding experience. It wasn’t just about showcasing the BiLSTM-CNN-CRF model or diving into the nitty-gritty of the implementation details in PyTorch, but seeing researchers and practitioners engage with this tutorial, ask thoughtful questions, and discuss their own challenges made all the preparation worth it.<p>If you have any thoughts, questions, or feedback, feel free to reach out—I’d love to hear from you!<blockquote class=note><p class=alert-title><i class=icon></i>Note<p>The work in this article was presented at ICML 2018, MLTrain Workshop “Enabling Reproducability in Machine Learning”.</blockquote><hr><ol class=footnotes-list><li id=fn-1><p>Link to the original paper: <a href=https://aclanthology.org/P16-1101/>End-to-end Sequence Labeling via Bi-directional LSTM-CNNs-CRF</a> <a href=#fr-1-1>↩</a></p><li id=fn-2><p>Link to the repository: <a href=https://github.com/TheAnig/NER-LSTM-CNN-Pytorch>NER-LSTM-CNN-Pytorch</a> <a href=#fr-2-1>↩</a></p></ol></article><hr><nav id=post-nav><a class="post-nav-item post-nav-prev" href=https://theanig.github.io/blog/deep-learning-for-memorable-quotes/> <div class=nav-arrow>Previous</div> <span class=post-title>Deep Learning Methods for Quotable Text</span> </a><a class="post-nav-item post-nav-next" href=https://theanig.github.io/blog/hilbert-curve-svm/> <div class=nav-arrow>Next</div> <span class=post-title>Using Fractals for feature extraction in image classification tasks</span> </a></nav><span class=hidden id=copy-code-text>Copy Code</span><span class=hidden id=search-index>https://theanig.github.io/search_index.en.json</span><span class=hidden id=more-matches-text>$MATCHES more matches</span></main><footer id=site-footer><nav><ul><li><a href=https://theanig.github.io/>About</a><li><a href=https://theanig.github.io/blog/>Blog</a></ul></nav><p>© TheAnig, 2025<ul id=socials><li><a rel=" me" href=https://discordapp.com/users/263024043391713281 title=Discord> <i style="--icon:url(&#34data:image/svg+xml,%3Csvg role='img' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EDiscord%3C/title%3E%3Cpath d='M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z'/%3E%3C/svg%3E&#34)" class=icon></i> <span>Discord</span> </a><li><a rel=" me" href=https://github.com/TheAnig title=GitHub> <i style="--icon:url(&#34data:image/svg+xml,%3Csvg role='img' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EGitHub%3C/title%3E%3Cpath d='M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12'/%3E%3C/svg%3E&#34)" class=icon></i> <span>GitHub</span> </a><li><a rel=" me" href=https://www.instagram.com/theanig_gattokun/ title=Instagram> <i style="--icon:url(&#34data:image/svg+xml,%3Csvg role='img' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3EInstagram%3C/title%3E%3Cpath d='M7.0301.084c-1.2768.0602-2.1487.264-2.911.5634-.7888.3075-1.4575.72-2.1228 1.3877-.6652.6677-1.075 1.3368-1.3802 2.127-.2954.7638-.4956 1.6365-.552 2.914-.0564 1.2775-.0689 1.6882-.0626 4.947.0062 3.2586.0206 3.6671.0825 4.9473.061 1.2765.264 2.1482.5635 2.9107.308.7889.72 1.4573 1.388 2.1228.6679.6655 1.3365 1.0743 2.1285 1.38.7632.295 1.6361.4961 2.9134.552 1.2773.056 1.6884.069 4.9462.0627 3.2578-.0062 3.668-.0207 4.9478-.0814 1.28-.0607 2.147-.2652 2.9098-.5633.7889-.3086 1.4578-.72 2.1228-1.3881.665-.6682 1.0745-1.3378 1.3795-2.1284.2957-.7632.4966-1.636.552-2.9124.056-1.2809.0692-1.6898.063-4.948-.0063-3.2583-.021-3.6668-.0817-4.9465-.0607-1.2797-.264-2.1487-.5633-2.9117-.3084-.7889-.72-1.4568-1.3876-2.1228C21.2982 1.33 20.628.9208 19.8378.6165 19.074.321 18.2017.1197 16.9244.0645 15.6471.0093 15.236-.005 11.977.0014 8.718.0076 8.31.0215 7.0301.0839m.1402 21.6932c-1.17-.0509-1.8053-.2453-2.2287-.408-.5606-.216-.96-.4771-1.3819-.895-.422-.4178-.6811-.8186-.9-1.378-.1644-.4234-.3624-1.058-.4171-2.228-.0595-1.2645-.072-1.6442-.079-4.848-.007-3.2037.0053-3.583.0607-4.848.05-1.169.2456-1.805.408-2.2282.216-.5613.4762-.96.895-1.3816.4188-.4217.8184-.6814 1.3783-.9003.423-.1651 1.0575-.3614 2.227-.4171 1.2655-.06 1.6447-.072 4.848-.079 3.2033-.007 3.5835.005 4.8495.0608 1.169.0508 1.8053.2445 2.228.408.5608.216.96.4754 1.3816.895.4217.4194.6816.8176.9005 1.3787.1653.4217.3617 1.056.4169 2.2263.0602 1.2655.0739 1.645.0796 4.848.0058 3.203-.0055 3.5834-.061 4.848-.051 1.17-.245 1.8055-.408 2.2294-.216.5604-.4763.96-.8954 1.3814-.419.4215-.8181.6811-1.3783.9-.4224.1649-1.0577.3617-2.2262.4174-1.2656.0595-1.6448.072-4.8493.079-3.2045.007-3.5825-.006-4.848-.0608M16.953 5.5864A1.44 1.44 0 1 0 18.39 4.144a1.44 1.44 0 0 0-1.437 1.4424M5.8385 12.012c.0067 3.4032 2.7706 6.1557 6.173 6.1493 3.4026-.0065 6.157-2.7701 6.1506-6.1733-.0065-3.4032-2.771-6.1565-6.174-6.1498-3.403.0067-6.156 2.771-6.1496 6.1738M8 12.0077a4 4 0 1 1 4.008 3.9921A3.9996 3.9996 0 0 1 8 12.0077'/%3E%3C/svg%3E&#34)" class=icon></i> <span>Instagram</span> </a><li><a rel=" me" href=https://www.linkedin.com/in/anirudh-ganesh95/ title=LinkedIn> <i style="--icon:url(&#34data:image/svg+xml,%3Csvg role='img' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3ELinkedIn%3C/title%3E%3Cpath d='M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z'/%3E%3C/svg%3E&#34)" class=icon></i> <span>LinkedIn</span> </a><li><a rel=" me" href=https://steamcommunity.com/id/TheAnig/ title=Steam> <i style="--icon:url(&#34data:image/svg+xml,%3Csvg role='img' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3ESteam%3C/title%3E%3Cpath d='M11.979 0C5.678 0 .511 4.86.022 11.037l6.432 2.658c.545-.371 1.203-.59 1.912-.59.063 0 .125.004.188.006l2.861-4.142V8.91c0-2.495 2.028-4.524 4.524-4.524 2.494 0 4.524 2.031 4.524 4.527s-2.03 4.525-4.524 4.525h-.105l-4.076 2.911c0 .052.004.105.004.159 0 1.875-1.515 3.396-3.39 3.396-1.635 0-3.016-1.173-3.331-2.727L.436 15.27C1.862 20.307 6.486 24 11.979 24c6.627 0 11.999-5.373 11.999-12S18.605 0 11.979 0zM7.54 18.21l-1.473-.61c.262.543.714.999 1.314 1.25 1.297.539 2.793-.076 3.332-1.375.263-.63.264-1.319.005-1.949s-.75-1.121-1.377-1.383c-.624-.26-1.29-.249-1.878-.03l1.523.63c.956.4 1.409 1.5 1.009 2.455-.397.957-1.497 1.41-2.454 1.012H7.54zm11.415-9.303c0-1.662-1.353-3.015-3.015-3.015-1.665 0-3.015 1.353-3.015 3.015 0 1.665 1.35 3.015 3.015 3.015 1.663 0 3.015-1.35 3.015-3.015zm-5.273-.005c0-1.252 1.013-2.266 2.265-2.266 1.249 0 2.266 1.014 2.266 2.266 0 1.251-1.017 2.265-2.266 2.265-1.253 0-2.265-1.014-2.265-2.265z'/%3E%3C/svg%3E&#34)" class=icon></i> <span>Steam</span> </a><li><a rel=" me" href=https://t.me/TheAnig title=Telegram> <i style="--icon:url(&#34data:image/svg+xml,%3Csvg role='img' viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'%3E%3Ctitle%3ETelegram%3C/title%3E%3Cpath d='M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z'/%3E%3C/svg%3E&#34)" class=icon></i> <span>Telegram</span> </a></ul></footer>